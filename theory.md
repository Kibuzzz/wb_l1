# Устные вопросы
## 1. Какой самый эффективный способ конкатенации строк?
Самый эффективный способ конкатенации строк - strings.Builder

Способы конкатенации строк:

1. Simple join using + - Simple concatenation of one or two small strings
2. strings.Builder - Efficient concatenation of large strings / inside loops
3. bytes.Buffer - Efficient concatenation of large strings / inside loops / reading from files
4. fmt.Sprint - Simple concatenation when using different data types
5. strings.Join - Concatenation of slice of string data types

https://eternaldev.com/blog/5-ways-to-concatenate-string-in-golang-with-reasons
## 2. Что такое интерфейсы, как они применяются в Go?
Интерфейсы в языке Go — это типы, которые определяют набор методов, но не реализуют их. Интерфейс задает контракт/поведение, которому должны соответствовать типы, реализующие этот интерфейс. Любой тип, который реализует все методы, определенные в интерфейсе, автоматически считается реализующим этот интерфейс, даже если явно не указано, что он его реализует.

Интерфейсы в Go помогают создавать гибкий, расширяемый и тестируемый код, позволяя различным типам данных работать вместе, если они следуют определенному контракту.
## 3. Чем отличаются RWMutex от Mutex?
RWMutex - это взаимоисключающая блокировка читателя и писателя. Блокировка может принадлежать произвольному числу читателей или одному писателю. Нулевое значение для RWMutex - это разблокированный мьютекс.

Читатели RWMutex не ждут друг друга, они только ждут писателей, которые сделали Lock.

RWMutex лучше использовать, когда данные в основном читаются, в этом случае RWMutex будет работать быстрее чем, обычный Mutex
## 4. Чем отличаются буферизированные и не буферизированные каналы?
У каждого канала в Go есть capacity (емкость). Канал, у которого capacity равен 0, называется небуферизированным каналом. Такие каналы также называются синхронными, так как они требуют одновременного присутствия отправителя и получателя для передачи данных. Небуферизированный канал блокируется, когда через него пытаются передать значение, до тех пор пока значение не будет получено.

С другой стороны, буферизированные каналы имеют ненулевую capacity. Они могут хранить данные в своем буфере до тех пор, пока не будет достигнута их емкость. Буферизированный канал блокируется только когда его буфер заполняется полностью, и передача данных при этом блокируется до тех пор, пока данные не будут прочитаны из буфера. Это позволяет более гибко управлять потоками данных, снижая уровень блокировки между отправителями и получателями.
## 5. Какой размер у структуры struct{}{}?
0 байт
## 6. Есть ли в Go перегрузка методов или операторов?
В Go нет перегрузки методов и операторов, но можно встраивать структуры и создавать методы с одним названием, но разной сигнатурой.
```golang
type Animal struct {
    Name string
}

func (a Animal) Speak() string {
    return "animal sound"
}

type Dog struct {
    Animal // Встраивание Animal
}

func (d Dog) Speak() string {
    return "Woof!"
}
```
## 7. В какой последовательности будут выведены элементы map[int]int?
Пример:
```golang
m[0]=1

m[1]=124

m[2]=281
```
 Элементы будут выведены в порядке возрастания. Map в го неупорядоченная, но если выводить через fmt.Println, то элементы будут выведены по возрастанию. За сортировку отвечает fmt.Println.
## 8. В чем разница make и new?
new возвращает указатель на нулевое значение указанного типа. При этом new просто выделяет память и инициализирует значение типа его “нулевым значением” (например, 0 для чисел, false для булевых, nil для map, slice и chan), но не готовит к использованию сложные типы, такие как карты, срезы или каналы.

make используется для создания и инициализации встроенных типов данных, таких как slice, map и chan, и возвращает готовое к использованию ненулевое значение этих типов. В отличие от new, make выделяет память и сразу инициализирует объект, чтобы он был готов к использованию.

Также с помощью new нельзя:
•	Создать канал (вернет nil канал, который не готов к использованию).
•	Создать map с выделенной памятью (вернет nil карту, для использования которой нужно сначала вызвать make).
•	Создать slice с предустановленной длиной и емкостью
## 9. Сколько существует способов задать переменную типа slice или map?
```golang
var varStyle []string
literalStyle := []string{}
newStyle := new([]string)
makeStyle := make([]string, 0)
```
```golang
var varStyle map[int]int
literalStyle = map[string]int{}
newStyle := new(map[string]int)
makeStyle := make(map[string]int)
```
## 10. Что выведет данная программа и почему?
```golang
func update(p *int) {
	b := 2
	p = &b
}

func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p)
	update(p)
	fmt.Println(*p)
}
```
Вывод:
```
1
1
```
Такой вывод потому что в Go значения в функцию передаются копией. Копия внутри функции update указывает на b, но оригинальный указатель не меняется и все также указывает на a.
## 11. Что выведет данная программа и почему?
```golang

```
## 12. Что выведет данная программа и почему?
```golang
func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}
```
Будут выведены цифры от 0 до 4 в случайном порядке, а потом ошибка. Ошибка произодит из за того, что в горутины передается копия WaitGroup, а не указатель. Поэтому все горутины отработают (выведут число и вызовут метод wg.Done), но wg в функции main так и продолжит и никогда не дождется, чтобы внутренний счетчик был равен 0 (deadlock).
## 13. Что выведет данная программа и почему?
```golang
func someAction(v []int8, b int8) {
	v[0] = 100
	v = append(v, b)
}

func main() {
	var a = []int8{1, 2, 3, 4, 5}
	someAction(a, 6)
	fmt.Println(a)
}
```
Программа выведет [100 2 3 4 5]. Срезы в Go представляют собой структуры, содержащие указатель на массив, len и cap. При передаче среза в функцию создается копия этой структуры, но оба среза (и в main, и в someAction) указывают на один и тот же массив. Когда внутри функции someAction выполняется v[0] = 100, это изменяет первый элемент исходного массива, что отражается в переменной a в main. Однако, когда вызывается v = append(v, b), емкость исходного массива оказывается недостаточной, поэтому append создает новый массив, копирует в него данные из старого и добавляет новый элемент, после чего v начинает указывать на этот новый массив, а a в main по-прежнему указывает на старый массив. Поэтому изменения после append не влияют на a, и она остается [100 2 3 4 5].
## 14. Что выведет данная программа и почему?
```golang
func main() {
	slice := []string{"a", "a"}
	func(slice []string) {
		slice = append(slice, "a")
		slice[0] = "b"
		slice[1] = "b"
		fmt.Print(slice)
	}(slice)
	fmt.Print(slice)
}
```
Будет выведено: [b b a][a a]
Внутри анонимной функции в slice добавляется новый элемент. Append увеличивает емкость слайса, добавляет туда новый элемент и возвращает новый slice. Дальше в новом slice элементы с индексами 0 и 1 становятся b. Происходит вывод этого слайса - [b b a]

Дальше выводится slice из функции main, который не изменялся - [a a]